<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Moon Pincho on lPinchol Moon&#39;s Blog</title>
    <link>https://moonantonio.github.io/categories/moon-pincho/index.xml</link>
    <description>Recent content in Moon Pincho on lPinchol Moon&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <copyright>© Antonio Moon.&lt;br&gt;Powered by [Hugo](//gohugo.io/) with the [Type Theme](//github.com/digitalcraftsman/hugo-type-theme)</copyright>
    <atom:link href="https://moonantonio.github.io/categories/moon-pincho/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C#: utilizar MEGA API CLIENT</title>
      <link>https://moonantonio.github.io/post/2017/programacion/001/</link>
      <pubDate>Wed, 01 Mar 2017 23:32:52 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/programacion/001/</guid>
      <description>&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://moonantonio.github.io/img/Dev/mega_icono1.png&#34; alt=&#34;001&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mega es el sucesor del servicio de archivos en la nube Megaupload, para aquellos a los que no les suena ninguno de los dos es como un dropbox, un servicio gratuito o de pago dependiendo del espacio que utilizamos para poder subir nuestros archivos. En mi opinión es un servicio increíble que nos permite almacenar copias de seguridad de archivos en la nube y/o compartirlos.&lt;/p&gt;

&lt;p&gt;En esta entrada mostraré como desde un proyecto en .Net en este caso con C# podéis subir archivos a mega. Además de subir archivos también podréis eliminar, modificar, mover y varias funciones más. Para comenzar tendréis que incorporar a vuestro proyecto varias referencias, si lo realizáis desde el administrador de paquetes nuget de Visual Studio ahorraréis tiempo y faena. Para abrir el administrador de paquetes nuget vamos a la barra principal de arriba y seleccionamos proyecto y administrar paquetes nuget. En la caja de búsqueda ponéis “mega.co.nz” sin comillas, y debe aparecer una librería que hará de cliente contra los servidores de mega, la seleccionáis y le dais a instalar. Además instalará automáticamente otra llamada Newtonsoft.Json que utilizará la librería mega para realizar algunas acciones.&lt;/p&gt;

&lt;p&gt;Tenemos el proyecto listo para empezar a utilizar los métodos y funciones que nos facilita mega en la clase que queramos, con ello vamos a la clase desde la que queramos que se suba el archivo y añadimos dos directivas using, la primera hace referencia a la api mega y la segunda nos permitirá crear un hilo y de este modo no bloquear nuestra aplicación mientras se realizan algunas tareas en línea:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;using CG.Web.MegaApiClient;
using System.Threading.Tasks;

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Ahora vamos con el método que se encargará de realizar la subida del archivo, actualizar la progressbar, y actualizar el texto de un label que irá informando al usuario de como va el proceso. El método es llamado dentro del evento “Shown” del form, y el form lo llamo mediante “ShowDialog()” desde el evento click de un botón de otro form, de esta manera es como una ventana emergente que no desaparecerá hasta que termine el proceso (entre 10 y 40 segundos). Para que quede mas claro, tenemos el “Form1” con un botón, este botón llamará al “Form2” mediante “ShowDialog()”, y dentro del evento “Shown” del “Form2” realizaremos la llamada al método encargado de subir el archivo “subirArchivoAMega()”.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;//Declaración de un hilo
 private Thread t;
 

 //Evento Shown que instancia y ejecuta el hilo (este evento se ejecuta después del Load).
 private void Form2_Shown(object sender, EventArgs e)
 {
     //Instancia un hilo para ejecutar el método &amp;quot;subirArchivoAMega&amp;quot;.
     t = new Thread(subirArchivoAMega);
     t.Start();
 }
// Método que se encarga de subir el archivo a la nuve con la api &amp;quot;Mega&amp;quot;.
private void subirArchivoAMega() {
    try {
          // Actualizar el label para informar al usuario.
          lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Conectando como &#39;tu_cuenta_de_email@gmail.com&#39;&amp;quot;; }));
          // Aumentar la barra de progreso.
          progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));
          // Instancia de un cliente para conectar con mega.
          MegaApiClient cliente = new MegaApiClient();
          // Inicio de sesión con el cliente, pasando el correo y la contraseña de la cuenta mega a la que se sube el archivo.
          cliente.Login(&amp;quot;tu_cuenta_de_email@gmail.com&amp;quot;, &amp;quot;****************&amp;quot;);

          // Aumentar la barra de progreso.
          progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));
          // Actualizar el label para informar al usuario.
          lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Obteniendo directorios...&amp;quot;; }));
          // Obtenemos los nodos (directorios/archivos) de la cuenta dentro de una variable.
          var nodos = cliente.GetNodes();

          // Actualizar el label para informar al usuario.
          lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Buscando carpeta &#39;Facturas&#39;...&amp;quot;; }));
          // Comprobar si existe algún nodo (directorio) que se llame &amp;quot;Facturas&amp;quot; (en mi caso quiero subir el archivo a dicha carpeta).
          bool existe = cliente.GetNodes().Any(n =&amp;gt; n.Name == &amp;quot;Facturas&amp;quot;);

          // Crear dos nodos.
          Node root;
          Node carpeta;

         // Si el directorio facturas existe, se obtiene. Si no existe, se crea.
         if (existe == true) {
              // Actualizar el label para informar al usuario.
              lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Obteniendo la carpeta &#39;Facturas&#39;....&amp;quot;; }));
              // Aumentar la barra de progreso.
              progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));

             // Obtenemos el directorio.
             carpeta = nodos.Single(n =&amp;gt; n.Name == &amp;quot;Facturas&amp;quot;);
         }else {
             // Actualizar label para informar al usuario.
             lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Creando carpeta &#39;Facturas&#39;...&amp;quot;; }));
             // Aumentar la barra de progreso.
             progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));

             //Obtenemos el nodo raíz.
             root = nodos.Single(n =&amp;gt; n.Type == NodeType.Root);
             // Creamos el directorio llamado &amp;quot;Facturas&amp;quot; en la raíz.
             carpeta = cliente.CreateFolder(&amp;quot;Facturas&amp;quot;, root);
         }

         // Aumentar la barra de progreso.
         progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));
         // Actualizar label para informar al usuario.
         lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Subiendo archivo...&amp;quot;; }));
         // Aumentar la barra de progreso.
         progressBar1.Invoke(new MethodInvoker(delegate { progressBar1.PerformStep(); }));

         // Subimos el archivo al directorio &amp;quot;Facturas&amp;quot;, pasando la ruta del archivo a subir y el directorio de mega donde debe subirlo.
         Node archivo = cliente.Upload(@&amp;quot;C\:Mis facturas\factura1.pdf&amp;quot;, carpeta);

         // Obtener el link de descarga del archivo subido por si se requiere para algo.
         Uri downloadUrl = cliente.GetDownloadLink(archivo);
         // Actualizar label para informar al usuario.
         lblInfo.Invoke(new MethodInvoker(delegate { lblInfo.Text = &amp;quot;Archivo subido con éxito.&amp;quot;; }));

    }catch (Exception error){
        // Algo ha fallado, abortamos el subproceso.
        t.Abort();
        // Mensaje en pantalla para informar al usuario del error.
        MessageBox.Show(&amp;quot;Error al intentar subir el archivo. &amp;quot; + error.Message, &amp;quot;Error&amp;quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
    }

    // No se puede cerrar el form desde un subproceso ya que no es desde donde se ha creado. Con este código podemos cerrarlo.
    this.Invoke((MethodInvoker)delegate{
        this.Close();
    });
}

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Si os fijáis, hago constantemente referencias a elementos del form, el motivo es para que el usuario sepa en todo momento la evolución del proceso. Para acceder a los componentes de un form no podemos hacerlo directamente desde un subproceso, por eso utilizamos el método “Invoke” que ejecuta el delegado asignado al subproceso y nos permite comunicarnos con el usuario.&lt;/p&gt;

&lt;p&gt;Finalmente muestro mi diseño del form para que veáis el total de elementos a los que hago referencia en el método, aunque podéis implementar el diseño que os guste.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://moonantonio.github.io/img/Dev/megaapiclient_upload_file.png&#34; alt=&#34;001&#34; /&gt;&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Witch and the Hundred Knight 2</title>
      <link>https://moonantonio.github.io/post/2017/noticias/001/</link>
      <pubDate>Wed, 01 Mar 2017 23:28:47 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/noticias/001/</guid>
      <description>

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://moonantonio.github.io/img/juegos/wc.jpg&#34; alt=&#34;001&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;anunciado-the-witch-and-the-hundred-knight-2-para-playstation-4&#34;&gt;Anunciado The Witch and the Hundred Knight 2 para PlayStation 4&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;El último número de la revista Famitsu revela que The Witch and the Hundred Knight 2 se lanzará en invierno de 2017 en las PlayStation 4 japonesas.&lt;/p&gt;

&lt;p&gt;El juego contará una nueva historia en un mundo diferente al de la primera entrega. En esta ocasión el tema será “brujas” y “enfermedad”, tomando los jugadores el rol del Hundred Knight (voz de Kaoru Mizuhara), invocado por la bruja Cerca para combatir bajo sus órdenes. El protagonismo estará compartido por el propio Hundred Knight y una chica llamada Amalie.&lt;/p&gt;

&lt;p&gt;Los personajes presentados son:
&amp;gt; * &lt;strong&gt;Mimil&lt;/strong&gt; (voz de Megumi Han) – La hermana menor de Amalie. Pasa por una operación debido a un tercer ojo que le aparece en la frente, lo que se conoce como “Enfermedad de la bruja”. La operación fracasa y se convierte en bruja.
&amp;gt; * &lt;strong&gt;Cerca&lt;/strong&gt; (voz de Megumi Han) – El nombre de Mimil convertida en bruja. Tiene un gran poder y solo obedece a sus propios deseos egoístas. En ocasiones vuelve a convertirse en Mimil debido a que su conversión fue imperfecta.
&amp;gt; * &lt;strong&gt;Funinmugin&lt;/strong&gt; (voz de Kenjiro Tsuda) – El familiar de Cerca. Un cuervo que se transforma en mayordomo para hacer las labores del hogar. Es gay y tiene hijos.
&amp;gt; * &lt;strong&gt;Amalie&lt;/strong&gt; (voz de Sachika Misawa) – Hermana mayor de Mimil. Pertenece a una organización antibrujas llamada WR (Weiss Ritter). Se enfrenta a la organización para proteger a su hermana, recién convertida en bruja.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://moonantonio.github.io/img/gif/001.gif&#34; alt=&#34;002&#34; /&gt;&lt;/center&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Otros datos del juego, incluyendo varios extraidos de una entrevista con el director Kenta Asano:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Los diseños del juego serán de Madoka Hanashiro.&lt;/li&gt;
&lt;li&gt;La oportunidad para crear este juego surgió tras el buen recibimiento del primer juego. Trabajaron en el port del primero y en esta segunda entrega al mismo tiempo.&lt;/li&gt;
&lt;li&gt;Se han revisado por completo los controles y esperan crear un sistema que encaje con la historia.&lt;/li&gt;
&lt;li&gt;El director y el diseñador de personajes cambian debido a que dan por concluida la historia de Metallia con el anterior juego. Este es un título completamente diferente.&lt;/li&gt;
&lt;li&gt;El volumen será equivalente o mayor al del primer juego.&lt;/li&gt;
&lt;li&gt;La base es la misma, pero se han hecho cambios para que la acción sea más cómoda, precisa y placentera. Habrá más tácticas.&lt;/li&gt;
&lt;li&gt;No habrá modos adicionales, pero como el mapa será procedural, el propio mapa de la historia será un elemento rejugable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;https://moonantonio.github.io/img/juegos/wc2.jpg&#34; alt=&#34;002&#34; /&gt;&lt;/center&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explicacion IA basica</title>
      <link>https://moonantonio.github.io/post/2017/clase/001/</link>
      <pubDate>Wed, 01 Mar 2017 23:25:12 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/clase/001/</guid>
      <description>

&lt;h1 id=&#34;ia-en-videojuegos-clase&#34;&gt;IA en Videojuegos (Clase)&lt;/h1&gt;

&lt;p&gt;Hay diferentes tipos de IA clasificados por el tipo de uso de su algoritmo.&lt;/p&gt;

&lt;p&gt;Los mas comunes en videojuegos son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Juegos de suma cero: Minimax&lt;/li&gt;
&lt;li&gt;Busqueda de caminos: A*&lt;/li&gt;
&lt;li&gt;Agentes inteligentes&lt;/li&gt;
&lt;li&gt;Maquina de estados finitos&lt;/li&gt;
&lt;li&gt;Redes neutonales&lt;/li&gt;
&lt;li&gt;Algoritmos geneticos&lt;/li&gt;
&lt;li&gt;Redes evolutivas: rtNeat&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Juegos de suma cero son juegos en los que solo tienen 2 resultados, o 3.
Como por ejemplo el ajedrez, Minimax es un algoritmo para realizar la eleccion de la mejor accion para ganar.&lt;/p&gt;

&lt;p&gt;Algoritmo Minimax: se basa en probar todas las posibles jugadas y sus respuestas hasta un nivel maximo.(Tic Tac Toe)&lt;/p&gt;

&lt;p&gt;El algoritmo responde con la mejor jugada posible suponiendo que el adversario tambien elige su mejor jugada.&lt;/p&gt;

&lt;p&gt;El termino poda alfa-beta es como bien dice la poda de ramas del arbol de eleccion para ahorrar tiempo y memoria de computacion.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Busqueda de caminos, A* es el algoritmo para que un objeto encuentre el camino y lo siga a voluntad.&lt;/p&gt;

&lt;p&gt;Este tipo de algoritmos se llaman pathfinding.&lt;/p&gt;

&lt;p&gt;Son algoritmos que buscan un camino existente entre un nodo inicial y un nodo final de un grafo.&lt;/p&gt;

&lt;p&gt;Se tienen en cuenta un coste entre nodos ( distancia, dificultad de l terreno).&lt;/p&gt;

&lt;p&gt;Algoritmos tipicos: Dijkstra, escalada, primero el mejor, A*&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Agentes inteligentes son algoritmos que cambian segun el estado del entorno.&lt;/p&gt;

&lt;p&gt;Un agente inteligente es una entidad que percibe y actua sobre un entorno de forma razonada.&lt;/p&gt;

&lt;p&gt;Las propiedades de un agente inteligente son:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Autonomia: actual por su cuenta propia.&lt;/li&gt;
&lt;li&gt;Inteligencia: cerrada o adaptable (Apendizaje)&lt;/li&gt;
&lt;li&gt;Actividad Reactiva: actua despues de algun suceso producido en el entorno.&lt;/li&gt;
&lt;li&gt;Actividad Proactivo: decide actuar antes de que se de un suceso.&lt;/li&gt;
&lt;li&gt;Sociabilidad: Cooperar con los aliados o ayudar sin que nos pidan ayuda.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Una maquina de estados finitos (SFM) es una entidad abstracta formada por estados y transiciones entre dichos estados.&lt;/p&gt;

&lt;p&gt;Cada estado representa una accion: moverse, disparar, perseguir &amp;hellip;&lt;/p&gt;

&lt;p&gt;Cuando se produce un evento, hay una transicion de un estado a otro: no hay enemigos, moverse, poca municion, etc&amp;hellip;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Una red de neuronas artificiales (RNA) es un sistema computacional que imita las capacidades de los sistemas biologicos utilizando muchos elementos simples interconectados.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clasifica patrones de entrada.&lt;/li&gt;
&lt;li&gt;Necesitan entrenamiento supervisado con muchos ejemplos.&lt;/li&gt;
&lt;li&gt;Son capaces de generalizar el reconocimiento de patrones.&lt;/li&gt;
&lt;li&gt;Una vez entrenadas, funcionan en tiempo real.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\.Moon Pincho&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comandos Git Fundamentales</title>
      <link>https://moonantonio.github.io/post/2017/utiles/001/</link>
      <pubDate>Wed, 01 Mar 2017 23:20:28 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/utiles/001/</guid>
      <description>

&lt;h1 id=&#34;los-comandos-fundamentales-que-se-usan-en-git&#34;&gt;Los comandos fundamentales que se usan en git.&lt;/h1&gt;

&lt;p&gt;Los comandos fundamentales que se usan en git son muchos, pero dependiendo del tipo de control de versiones que uno esta realizando en ese momento.&lt;/p&gt;

&lt;p&gt;Por ejemplo si estas haciendo un control de versiones de un proyecto en el que solo participas tu, usaras los indispensables ya que con dejar el proyecto abierto para que otros puedas entrar sin problemas de cambiar la config sobra.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;inicializar&#34;&gt;Inicializar:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git init {Crea un nuevo repositorio}
git clone /path/to/repository {Crea una copia local del repositorio}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;registro&#34;&gt;Registro&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git add &amp;lt;filename&amp;gt; {Agrega solo el fichero dado al registro}
git add . {Agrega todos los cambios realizados al registro}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;empaquetado&#34;&gt;Empaquetado&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git commit -m &amp;quot;Mensaje&amp;quot; {Empaqueta el registro para ser mandado}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;envio&#34;&gt;Envio&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push origin master {Envia el paquete(Commit) por la rama &amp;quot;master&amp;quot; al repositorio}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ramas&#34;&gt;Ramas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git checkout -b dev {Crea una rama llamada &amp;quot;dev&amp;quot; y cambiate a ella}
git checkout master {Cambiar de rama}
git branch -d dev {Borra la rama &amp;quot;dev&amp;quot;}
git push origin &amp;lt;branch&amp;gt; {Envia al repositorio la nueva rama para actualizarla a todo el mundo}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;actualizacion&#34;&gt;Actualizacion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git pull {Descarga los nuevos cambios del repositorio}
git merge &amp;lt;branch&amp;gt; {Fusiona la rama dada con tu rama actual}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;etiquetas&#34;&gt;Etiquetas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag 1.0.0 {Creas una nueva etiqueta llamada 1.0.0}
git tag 1.0.0 1b2e1d63ff {Creas una nueva etiqueta haciendo referencia a 1b2e1d63ff, que es el id del commit}
git log {Sacas el id del commit}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y eso es todo de momento. Estos son los comandos que mas usaras. Pero si quieres pasar de usar consola y te ves mas comodo con una interfaz grafica, puedes usar diferentes clientes tales como:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://desktop.github.com/&#34; class=&#34;button&#34;&gt;GitHub Desktop(Win &amp;amp; Mac)&lt;/a&gt;&lt;a href=&#34;https://www.sourcetreeapp.com/&#34; class=&#34;button&#34;&gt;SourceTree(Win &amp;amp; Mac)&lt;/a&gt;&lt;a href=&#34;https://www.gitkraken.com/&#34; class=&#34;button&#34;&gt;GitKraken(Win/Mac/Linux)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Nuevo Blog</title>
      <link>https://moonantonio.github.io/post/2017/diario/nuevo-blog/</link>
      <pubDate>Mon, 27 Feb 2017 12:39:36 +0100</pubDate>
      
      <guid>https://moonantonio.github.io/post/2017/diario/nuevo-blog/</guid>
      <description>

&lt;h1 id=&#34;nuevo-blog-con-una-nueva-estructura&#34;&gt;Nuevo blog con una nueva estructura.&lt;/h1&gt;

&lt;p&gt;Despues del cambio de nombre en GitHub y en las demas plataformas, e decidio tambien cambiar el blog.&lt;/p&gt;

&lt;p&gt;Visualmente es el mismo, pero internamente se han realizado unos cambios para una mejor distribucion.&lt;/p&gt;

&lt;p&gt;Ahora va todo por secciones. ^^&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>