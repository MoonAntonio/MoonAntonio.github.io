<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">

        <title>The Book of Shaders</title>
        <link href="..\..\favicon.gif" rel="shortcut icon">
        <meta name="keywords" content="shader,openGL,WebGL,GLSL,book,procedural,generative">
        <meta name="description" content="Gentle step-by-step guide through the abstract and complex universe of Fragment Shaders.">

        <!— Open Graph data —>
        <meta property="og:type" content="article">
        <meta property="og:title" content="The Book of Shaders">
        <meta property="og:site_name" content="The Book of Shaders">
        <meta property="og:description" content="Gentle step-by-step guide through the abstract and complex universe of Fragment Shaders.">
        <meta property="og:image" content="http://thebookofshaders.com/thumb.png">
        <meta property="og:image:secure_url" content="https://thebookofshaders.com/thumb.png">
        <meta property="og:image:type" content="image/png">
        <meta property="og:image:width" content="500">
        <meta property="og:image:height" content="500">


        <!— Twitter Card—>
        <meta name="twitter:card" content="image">
        <meta name="twitter:site" content="@bookofshaders">
        <meta name="twitter:creator" content="@patriciogv">
        <meta name="twitter:title" content="The Book Of Shaders">
        <meta name="twitter:domain" content="thebookofshaders.com">
        <meta name="twitter:description" content="Gentle step-by-step guide through the abstract and complex universe of Fragment Shaders.">
        <meta name="twitter:image" content="https://thebookofshaders.com/thumb.png">
        <meta name="twitter:image:width" content="500">
        <meta name="twitter:image:height" content="500">


        <link href="..\..\favicon.gif" rel="shortcut icon">

        <!-- Highlight -->

        <link type="text/css" rel="stylesheet" href="..\..\css\github.css">
        <script type="text/javascript" src="..\..\src\highlight.min.js"></script>
        <!-- GlslCanvas -->

        <script type="text/javascript" src="..\..\src\glslCanvas\build\GlslCanvas.js"></script>
        <!-- GlslEditor -->

        <link type="text/css" rel="stylesheet" href="..\..\glslEditor\glslEditor.css">
        <script type="application/javascript" src="..\..\glslEditor\glslEditor.js"></script>
        <!-- GlslGallery -->

        <link type="text/css" rel="stylesheet" href="..\..\glslGallery\glslGallery.css">
        <script type="application/javascript" src="..\..\glslGallery\glslGallery.js"></script>
        <!-- Main style -->

        <link type="text/css" rel="stylesheet" href="..\..\css\style.css">
    </head>
    <body>

    <div class="header">
        <p class="subtitle"><a href="..\..\index-8.html">The Book of Shaders</a> by <a href="http://patriciogonzalezvivo.com">Patricio Gonzalez Vivo</a> & <a href="http://jenlowe.net">Jen Lowe</a> </p>
        <p> <a href="index-4.html?lan=jp">日本語</a> - <a href="index-5.html?lan=ch">中文版</a> - <a href="index-6.html?lan=kr">한국어</a> - <a href="index-7.html?lan=es">Español</a> - <a href="index.html?lan=fr">Français</a> - <a href="index-8.html?lan=it">Italiano</a> - <a href="index-2.html?lan=de">Deutsch</a> - <a href="index-3.html?lan=ru">Русский</a> - <a href="index-1.html">English</a></p>
    </div>
    <hr>
<div id="content"><h2>Введение для JavaScript-программистов</h2>
<p>автор <a href="http://www.barradeau.com/">Николя Баррадо</a></p>
<p>Если вы JavaScript-разработчик, велика вероятность, что вы будете немного озадаченЫ, читая эту книгу. В самом деле, есть множество различий между манипулированием высокоуровневыми абстракциями на JS и ковырянием в шейдерах. Но, в отличие от лежащего на более низком уровне языка ассемблера, GLSL является человекочитаемым, и я уверен, что разобравшись с его особенностями, вы быстро сможете начать его использовать.</p>
<p>Я предполагаю, что у вас есть хотя бы поверхностные знания JavaScript и Canvas API. Если это не так - ничего страшного. Вам всё равно будет интересно читать большую часть этой главы.</p>
<p>Так же, я не буду сильно углубляться в детали, и некоторые вещи могут быть лишь <em>полуправдой</em>. Эта глава не является подробным руководством.</p>
<p>JavaScript очень хорош для быстрого прототипирования. Вы можете беспорядочно набросать кучу нетипизированных переменных и методов, динамически добавлять и удалять члены класса, обновить страницу и увидеть как она работает. Затем сделать изменения в соответствии с увиденным, обновить страницу, повторить. Жизнь - простая штука. Так в чём же разница между JavaScript и GLSL? Они оба работают в браузере, оба используются для рисования всяких прикольных штук на экране, и к тому же, JS проще в использовании.</p>
<p>ОСновная разница в том, что JavaScript - <strong>интерпретируемый</strong> язык, в то время как GLSL - <strong>компилируемый</strong>. <strong>Скомпилированная</strong> программа исполняется нативно, она является низкоуровневой и в целом высокопроизводительна. <strong>Интерпретируемая</strong> программа требует <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%B0">виртуальную машину</a> для своего исполнения, является высокоуровневой и в общем случае более медленной.</p>
<p>Когда браузер (<em><strong>виртуальная машина</strong> JavaScript</em>) <strong>исполняет</strong> или <strong>интерпретирует</strong> кусок кода на JS, он не имеет ни малейшего понятия чем является каждая переменная и что делает каждая функция (за исключением <strong>типизированных массивов</strong>). Поэтому он не может оптимизировать что-либо <em>наперёд</em>. Чтение кода браузером занимает какое-то время, чтобы <strong>вывести</strong> (исходя из использования) типы переменных и методов, и, по возможности, преобразовать <em>часть</em> кода в ассемблер, который будет исполняться намного быстрее.</p>
<p>Это медленный, болезненный и до сумасшествия сложный процесс. Если вам интересны подробности, рекомендую посмотреть как <a href="https://developers.google.com/v8/">работает движок V8 в Хроме</a>. Хуже всего то, что браузер оптимизирует JS как ему хочется, и этот процесс <em>скрыт</em> от программиста. Вы бессильны.</p>
<p><strong>Компилируемая</strong> программа не интерпретируется на ходу. Её запускает операционная система, и она исполняется, если она корректна. Это многое меняет. Если вы забудете точку с запятой в конце строки, ваш код станет некорректным и просто не скомпилируется. Он вообще не превратится в программу.</p>
<p>Это сурово, но это то, чем является <strong>шейдер</strong>: <em>компилируемая программа для исполнения на GPU</em>. Не пугайтесь! <strong>Компилятор</strong>, то есть та программа которая проверяет ваш код на корректность, станет вашим лучшим другом. Примеры и <a href="http://editor.thebookofshaders.com/">редактор</a> в этой книге очень дружественны к пользователю. Она подскажут в каком месте программа не скомпилировалась, и когда после всех правок шейдер будет готов к компиляции, результат его работы будет немедленно отображён. Это отличный способ обучения в силу его наглядности и невозможности что-либо сломать.</p>
<p>И последнее: <strong>шейдер</strong> состоит из двух программ: <strong>вершинного</strong> и <strong>фрагментного</strong> шейдера. Вкратце, вершинный шейдер (первая программа) принимает на вход и преобразовывет <em>геометрию</em>, которая затем превращается в последовательность <strong>пикселей</strong> (или <strong>фрагментов</strong>), поступающих на вход второго шейдера. И уже второй шейдер решает в какой цвет нужно покрасить пиксели. Эта книга посвящена именно вторым шейдерам. Во всех примерах геометрия - это прямоугольник, покрывающий всю доступную область.</p>
<p>Готовы?</p>
<p>Поехали!</p>
<h3>Сильная типизация</h3>
<p><img src="strong_type.jpg" alt="первая картинка в Гугле по запросу «сильные типы» на 20 мая 2016"></p>
<p>Когда вы приходите с JS или любого другого нетипизированного языка, <strong>типизирование</strong> переменных является для вас чужеродной концепцией, и это станет сложнейшим шагом при переходе к GLSL. <strong>Типизация</strong>, как легко догадаться, означает, что вам придётся давать <strong>тип</strong> каждой переменной и функции. Отсюда следует, что ключевого слова <strong><code>var</code></strong> больше не существует. Считайте, что полиция мыслей от GLSL стёрла его из общеупотребимого языка и вы больше не можете его произносить потому что, ну... его не существует.</p>
<p>Вместо использования волшебного слова <strong><code>var</code></strong> вам придётся <em>явно указывать тип каждой переменной</em>, тогда компилятор увидит те объекты и примитивы, с которыми он умеет эффективно обращаться. Обратная сторона невозможности использования ключевого слова <strong><code>var</code></strong> заключается в том, что вам нужно очень хорошо знать особенности типов всех переменных. Но поверьте, типов в GLSL немного, и они все достаточно просты (GLSL - не Java-фреймворк).</p>
<p>Всё это может выглядеть пугающе, но всё же это не сильно отличается от того, что вы обычно делаете на JS. Например, если переменная булева, то в ней может храниться только <code>true</code> или <code>false</code>. Если переменная называется <code>var uid = XXX;</code>, то в ней вероятно хранится целочисленное значение. Если же она объявлена как <code>var y = YYY;</code>, то это <em>возможно</em> ссылка на значение с плавающей точкой. Что ещё лучше, при использовании сильных типов вам не придётся гадать что означает <code>X == Y</code>, и означает ли это <code>typeof X == typeof Y</code>, или <code>typeof X !== null &amp;&amp; Y...</code>. В любом случае, вы <em>знаете</em> что здесь написано, а если и не знаете, то компилятор знает точно.</p>
<p>Перечислим <strong>скалярные типы</strong> языка GLSL (<strong>скаляр</strong> описывает количество): <code>bool</code> (булев тип), <code>int</code> (целочисленный) и <code>float</code> (значения с плавающей точкой). Есть и другие типы, но пока давайте рассмотрим как объявляются переменные в GLSL:</p>
<pre><code class="language-glsl">// булево значение
JS: var b = true;               GLSL: bool b = true;

// целое значение
JS: var i = 1;                  GLSL: int i = 1;

// число с плавающей точкой
JS: var f = 3.14159;            GLSL: float f = 3.14159;</code></pre>
<p>Не очень трудно, правда? Как было замечено выше, такой подход делает программирование проще, так как вы не тратите время на выслеживание типа какой-либо переменной. Всё ещё сомневаетесь? Помните, что это так же делается для того, чтобы ваша программа исполнялась в разы быстрее, чем на JS.</p>
<h4>void</h4>
<p>В GLSL есть тип <code>void</code>, который приблизительно соответствует <code>null</code>. Он используется в качестве возвращаемого типа для метода, который не возвращает ничего, и вы не можете объявить переменную этого типа.</p>
<h4>boolean</h4>
<p>Как вам известно, булевы значения в основном используются для проверки условий: <code>if( myBoolean == true ){}else{}</code>. Условное ветвление очень легко использовать на CPU, но <a href="http://thebookofshaders/01/?lan=ru">параллельная природа</a> GLSL делает это утверждение не совсем верным. Как правило, использование условных переходов не рекомендуется, и в книге описано несколько способов обойти это ограничение.</p>
<h4>приведение типов</h4>
<p>Как говорил <a href="https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D1%80%D0%BE%D0%BC%D0%B8%D1%80">Боромир</a>, нельзя просто так взять и смешать типизированные примитивы. В отличие от JavaScript, GLSL не позволит вам выполнять операции между переменными различных типов.</p>
<p>Например вот это:</p>
<pre><code class="language-glsl">int     i = 2;
float   f = 3.14159;

// попытка умножить целое на значение с плавающей точкой
float   r = i * f;</code></pre>
<p>не будет работать, потому что вы пытаетесь скрестить <strong><em>кошку</em></strong> с <strong><em>жирафом</em></strong>. Проблема решается с помощью <strong>приведения типов</strong>, которое <em>заставит компилятор поверить</em>, что <em><code>i</code></em> имеет тип <code>float</code>, не меняя фактический тип <em><code>i</code></em>.</p>
<pre><code class="language-glsl">//приведение типа целочисленной переменной 'i' к float
float   r = float( i ) * f;</code></pre>
<p>Это в точности как переодевание <strong><em>кошки</em></strong> в <strong>шкуру <em>жирафа</em></strong>, которое будет работать как и ожидается: в <code>r</code> сохранится результат умножения <code>i</code> x <code>f</code>.</p>
<p>Любой из упомянутых выше типов можно <strong>привести</strong> к любому другому. При этом приведение <code>float</code> к <code>int</code> будет работать как <code>Math.floor()</code>, удаляя числа справа от запятой. Приведение <code>float</code> или <code>int</code> к булеву типу вернёт <code>true</code> если переменная не равна нулю.</p>
<h4>конструктор</h4>
<p><strong>Типы</strong> переменных так же являются <strong>конструкторами классов</strong> для самих себя. Фактически, переменную типа <code>float</code> можно представлять как <em><code>экземпляр</code></em> класса <em><code>float</code></em>.</p>
<p>Следующие объявления равнозначны:</p>
<pre><code class="language-glsl">int     i = 1;
int     i = int( 1 );
int     i = int( 1.9995 );
int     i = int( true );</code></pre>
<p>Для <code>скалярных</code> типов это выглядит весьма тривиально, не особо отличаясь от <strong>приведения</strong>, но в этом появится больше смысла когда мы дойдём до раздела о <em>перегрузках</em>.</p>
<p>Итак, мы изучили три <code>примитивных типа</code>, без которых невозможно обойтись, но в GLSL есть и другие.</p>
<h3>Векторы</h3>
<p><img src="vector.jpg" alt="первый результат в Гугле по запросу 'vector villain' на 20 мая 2016"></p>
<p>Как и JavaScript, в GLSL вам понадобятся более продвинутые способы для манипуляции данными, и здесь <strong><code>векторы</code></strong> будт очень кстати. Я предполагаю, что вам доводилось писать на JS класс <code>Point</code>, который содержит значения <code>x</code> и <code>y</code>, и выглядит как-то так:</p>
<pre><code class="language-glsl">// определение:
var Point = function( x, y ){
    this.x = x || 0;
    this.y = y || 0;
}

// объявление экземпляра:
var p = new Point( 100,100 );</code></pre>
<p>Как мы только что видели, этот код жутко неправилен на всех уровнях. Во-первых, это ключевое слово <strong><code>var</code></strong>, затем это ужасающее <strong><code>this</code></strong> и <strong>нетипизированные</strong> значения <code>x</code> и <code>y</code>... Нет, такое явно не будет работать в мире шейдеров.</p>
<p>Вместо этого GLSL предоставляет встроенные структуры для группировки данных:</p>
<ul>
<li><code>bvec2</code>: 2D булев вектор, <code>bvec3</code>: 3D булев вектор, <code>bvec4</code>: 4D булев вектор</li>
<li><code>ivec2</code>: 2D целочисленный вектор, <code>ivec3</code>: 3D целочисленный вектор, <code>ivec4</code>: 4D целочисленный вектор</li>
<li><code>vec2</code>: 2D вектор с плавающей точкой, <code>vec3</code>: 3Dвектор с плавающей точкой, <code>vec4</code>: 4D вектор с плавающей точкой</li>
</ul>
<p>Вдумчивый читатель заметит, что каждому примитивному типу соответствует <strong>векторный</strong> тип. Из написанного выше легко вывести, что <code>bvec2</code> содержит два булевых значения, а <code>vec4</code> будет содержать четыре значения в плавающей точкой.</p>
<p>Так же векторы вводят такую величину, как размерность. Это не означает, что вы должны использовать 2D-вектор при отрисовке 2D-графики и 3D при рисовании 3D-изображений. Для чего в таком случае используется четырёхмерный вектор? (ну, на самом деле это называется «тессеракт» или «гиперкуб»)</p>
<p>Нет, <strong>размерность</strong> указывает на количество <strong>компонентов</strong> или <strong>переменных</strong>, хранимых в <strong>векторе</strong>:</p>
<pre><code class="language-glsl">// объявляем двумерный булев вектор
bvec2 b2 = bvec2 ( true, false );

// объявляем трёхмерный целочисленный вектор
ivec3 i3 = ivec3( 0,0,1 );

// объявляем четырёхмерный вектор значений с плавающей запятой
vec4 v4 = vec4( 0.0, 1.0, 2.0, 1. );</code></pre>
<p><code>b2</code> содержит два различных булевых значения, <code>i3</code> содержит 3 различных целых, а <code>v4</code> содержит 4 различных значения с плавающей точкой.</p>
<p>Но как обратиться к этим значениям?
В случае скаляров ответ очевиден: при объявлении <code>float f = 1.2;</code> переменная <code>f</code> содержит значение <code>1.2</code>. Для <strong>векторов</strong> всё немного по-другому и выглядит это довольно красиво.</p>
<h4>доступ к элементам векторов</h4>
<p>Есть несколько способов доступа к значениям</p>
<pre><code class="language-glsl">// объявим четырёхмерный вектор значений с плавающей точкой
vec4 v4 = vec4( 0.0, 1.0, 2.0, 3.0 );</code></pre>
<p>четыре его значения можно извлечь следующим образом</p>
<pre><code class="language-glsl">float x = v4.x;     // x = 0.0
float y = v4.y;     // y = 1.0
float z = v4.z;     // z = 2.0
float w = v4.w;     // w = 3.0</code></pre>
<p>легко и просто. Ниже приведены равнозначные способы доступа к данным:</p>
<pre><code class="language-glsl">float x =   v4.x    =   v4.r    =   v4.s    =   v4[0];     // x = 0.0
float y =   v4.y    =   v4.g    =   v4.t    =   v4[1];     // y = 1.0
float z =   v4.z    =   v4.b    =   v4.p    =   v4[2];     // z = 2.0
float w =   v4.w    =   v4.a    =   v4.q    =   v4[3];     // w = 3.0</code></pre>
<p>Вдумчивый читатель заметил три факта:</p>
<ul>
<li><code>X</code>, <code>Y</code>, <code>Z</code> и <code>W</code> как правило используются в программах для представления векторов в пространстве</li>
<li><code>R</code>, <code>G</code>, <code>B</code> и <code>A</code> используются для кодирования цвета и альфа-канала</li>
<li><code>[0]</code>, <code>[1]</code>, <code>[2]</code> и <code>[3]</code> означают, что векторы являются массивами с произвольным доступом</li>
</ul>
<p>В зависимости от того, работаете ли вы с двух- или трёхмерными координатами, цветом с альфа-каналом или без такового, или просто какими-то произвольными значениями, вы можете выбрать наиболее подходящий тип и размерность вектора. Обычно координаты и векторы (в геометрическом смысле слова) хранятся как <code>vec2</code>, <code>vec3</code> или <code>vec4</code>, цвета как <code>vec3</code> или <code>vec4</code>, но в целом никаких ограничений на использование переменных нет. Например, никто не запрещает вам хранить единственное булево значение как <code>bvec4</code>, но это приведёт в излишнему расходу памяти.</p>
<p><strong>Заметим</strong>, что в шейдерах значения цвета (<code>R</code>, <code>G</code>, <code>B</code>, <code>A</code>) нормализованы, то есть лежат в диапазоне от 0 до 1, а не от 0 до 0xFF, поэтому для них лучше использовать вещественный тип <code>vec4</code>, а не целочисленный <code>ivec4</code>.</p>
<p>Уже лучше, но мы идём далее!</p>
<h4>перемешивание</h4>
<p>Из вектора можно извлечь несколько значений одновременно. Например, если вам нужны только <code>X</code> и <code>Y</code> из <code>vec4</code>, на JavaScript вы бы написали что-то вроде этого:</p>
<pre><code class="language-glsl">var needles = [0, 1]; // размещение 'x' и 'y' в структуре данных
var a = [ 0,1,2,3 ]; // структура данных 'vec4'
var b = a.filter( function( val, i, array ) {
return needles.indexOf( array.indexOf( val ) ) != -1;
});
// b = [ 0, 1 ]

// или более буквально:
var needles = [0, 1];
var a = [ 0,1,2,3 ]; // структура 'vec4'
var b = [ a[ needles[ 0 ] ], a[ needles[ 1 ] ] ]; // b = [ 0, 1 ]</code></pre>
<p>Выглядит уродливо. В GLSL данные можно извлечь вот так:</p>
<pre><code class="language-glsl">// создаём четырёхмерный вектор с плавающей запятой
vec4 v4 = vec4( 0.0, 1.0, 2.0, 3.0 );

// и извлекаем только X и Y
vec2 xy =   v4.xy; //   xy = vec2( 0.0, 1.0 );</code></pre>
<p>Что это было?! Когда вы составляете воедино методы доступа к полям, GLSL изящно возвращает запрошенное подмножество в виде значения наиболее подходящего типа. Это возможно, потому что вектор является структурой данных с произвольным доступом, прямо как массив в javaScript. Поэтому, можно не только обратиться к подмножеству данных вектора, но и указать <strong>порядок</strong>, в котором нужно обращаться. Следующий код обратит порядок компонентов вектора:</p>
<pre><code class="language-glsl">// создаём четырёхкомпонентный вектор R,G,B,A
vec4 color = vec4( 0.2, 0.8, 0.0, 1.0 );

// и извлекаем компоненты цвета в порядке A,B,G,R
vec4 backwards = v4.abgr; // backwards = vec4( 1.0, 0.0, 0.8, 0.2 );</code></pre>
<p>И конечно же, к одной компоненте можно обратиться многократно:</p>
<pre><code class="language-glsl">// создаём четырёхкомпонентный вектор R,G,B,A
vec4 color = vec4( 0.2, 0.8, 0.0, 1.0 );

// и извлекаем vec3 с компонентами GAG на основе каналов G и A исходного цвета
vec3 GAG = v4.gag; // GAG = vec4( 0.8, 1.0, 0.8 );</code></pre>
<p>Очень удобно составлять части вектора воедино, извлекать только rgb-компоненты из вектора цвета с прозрачностью и т.п.</p>
<h4>перегрузим всё!</h4>
<p>В разделе о типах я упоминал упоминал <strong>конструкторы</strong> и ещё одно великолепное свойство языка GLSL - <strong>перегрузку</strong>. <strong>Перегрузка</strong> оператора или функции означает <em>изменение поведения этого оператора или функции в зависимости от операндов/аргументов</em>. В JavsScript нет перегрузки, поэтому вначале она может показаться вам странной, но немного попользовавшись ей, вы зададитесь вопросом, почему же она не реализована в JavaScript (краткий ответ - <em>типизация</em>).</p>
<p>Рассмотрим простейший пример перегрузки:</p>
<pre><code class="language-glsl">vec2 a = vec2( 1.0, 1.0 );
vec2 b = vec2( 1.0, 1.0 );
// перегруженное сложение
vec2 c = a + b;     // c = vec2( 2.0, 2.0 );</code></pre>
<p>ШТОА? Можно складывать сущности, не являющиеся числами?!</p>
<p>Именно. И конечно же, это применимо ко всем операторам (<code>+</code>, <code>-</code>, <code>*</code> и <code>/</code>), и это только начало.
Рассмотрим фрагмент кода:</p>
<pre><code class="language-glsl">vec2 a = vec2( 0.0, 0.0 );
vec2 b = vec2( 1.0, 1.0 );
// перегруженный конструктор
vec4 c = vec4( a , b );         // c = vec4( 0.0, 0.0, 1.0, 1.0 );</code></pre>
<p>Мы соорудили <code>vec4</code> из двух <code>vec2</code>, используя <code>a.x</code> и <code>a.y</code> в качестве компонент <code>X</code> и <code>Y</code> для нового вектора <code>c</code>. Затем мы взяли <code>b.x</code> и <code>b.y</code> в качестве <code>Z</code> и <code>W</code> для <code>c</code>.</p>
<p>Так работает перегрузка функции по набору параметров, в данном случае это <strong>конструктор</strong> <code>vec4</code>. Это означает, что несколько <strong>версий</strong> одного и того же метода с различными наборами параметров могут мирно сосуществовать в одной программе. Например, все следующие объявления корректны:</p>
<pre><code class="language-glsl">vec4 a = vec4(1.0, 1.0, 1.0, 1.0);
vec4 a = vec4(1.0);// x, y, z, w all equal 1.0
vec4 a = vec4( v2, float, v4 );// vec4( v2.x, v2.y, float, v4.x );
vec4 a = vec4( v3, float );// vec4( v3.x, v3.y, v3.z, float );
etc.</code></pre>
<p>От вас требуется только подать достаточное количество параметров для заполнения <strong>вектора</strong>.</p>
<p>Наконец, вы можете перегружать встроенные функции для тех типов аргументов, для которых они не были изначально задуманы (но лучше не делать этого слишком часто).</p>
<h4>нужно больше типов</h4>
<p>Векторы прикольные. Они - мышцы вашего шейдера. Но есть и другие типы, например матрицы и текстурные семплеры, о которых будет рассказано ниже.</p>
<p>В GLSL есть массивы. Конечно же, они типизированные, и у них есть несколько отличий от массивов в JS:</p>
<ul>
<li>у них фиксированный размер</li>
<li>вы не можете использовать push(), pop(), splice() и т.п., свойство <code>length</code> тоже отсутствует</li>
<li>их нельзя инициализировать значениями при объявлении</li>
<li>значения нужно задавать по одному</li>
</ul>
<p>вот это работать не будет:</p>
<pre><code class="language-glsl">int values[3] = [0,0,0];</code></pre>
<p>а вот это заработает:</p>
<pre><code class="language-glsl">int values[3];
values[0] = 0;
values[1] = 0;
values[2] = 0;</code></pre>
<p>Этого хватает, если вы знаете все ваши данные или работаете с небольшими массивами данных. Если вам нужно больше выразительности, вы можете использовать структуры (<code>struct</code>). Они похожи на <em>объекты</em> без методов. Они позволяют хранить несколько переменных в одном объекте:</p>
<pre><code class="language-glsl">struct ColorStruct {
    vec3 color0;
    vec3 color1;
    vec3 color2;
}</code></pre>
<p>например, вы можете задавать и извлекать значения <em>цвета</em> следующим образом:</p>
<pre><code class="language-glsl">// инициализируем структуру
ColorStruct sandy = ColorStruct(    vec3(0.92,0.83,0.60),
                                    vec3(1.,0.94,0.69),
                                    vec3(0.95,0.86,0.69) );

// получем доступ к значениям
sandy.color0 // vec3(0.92,0.83,0.60)</code></pre>
<p>Это синтаксический сахар, но он может помочь вам писать более чистый, или как минимум более привычный код.</p>
<h4>выражения и условия</h4>
<p>Структуры данных очень полезны, но рано или поздно  нам <em>возможно</em> понадобится проходить по массиву или выполнять проверку условия. К счастью, синтаксис для этого очень близок к JavaScript.
Условие выглядит так:</p>
<pre><code class="language-glsl">if( condition ){
    //true
}else{
    //false
}</code></pre>
<p>Цикл <code>for</code> выглядит так:</p>
<pre><code class="language-glsl">const int count = 10;
for( int i = 0; i &lt;= count; i++){
    //do something
}</code></pre>
<p>пример переменной цикла с плавающей точкой:</p>
<pre><code class="language-glsl">const float count = 10.;
for( float i = 0.0; i &lt;= count; i+= 1.0 ){
    //do something
}</code></pre>
<p>Заметим, что <code>count</code> должна быть объявлена константой. Это означает, что перед её объявлением должен быть <strong>квалификатор</strong> <code>const</code>, который будет рассмотрен чуть ниже.</p>
<p>Так же нам доступны ключевые слова <code>break</code> и <code>continue</code>:</p>
<pre><code class="language-glsl">const float count = 10.;
for( float i = 0.0; i &lt;= count; i+= 1.0 ){
    if( i &lt; 5. )continue;
    if( i &gt;= 8. )break;
}</code></pre>
<p>Имейте ввиду, что на некоторых типах оборудования <code>break</code> не работает ожидаемым образом и не прерывает цикл заранее.</p>
<p>В целом, старайтесь делать количество итераций как можно меньше, и избегайте циклов и ветвлений как можно чаще.</p>
<h4>квалификаторы</h4>
<p>Помимо типов переменных в GLSL есть <strong>квалификаторы</strong>. Вкратце, квалификаторы сообщают компилятору какая переменная для чего предназначена. Например, некоторые данные для GPU могут приходить только со стороны CPU. Такие данные называются <strong>атрибутами</strong> и <strong>юниформами</strong>. <strong>Атрибуты</strong> встречаются только в вершинных шейдерах, а <strong>юниформы</strong> - и в вершинных, и во фрагментных. Так же есть квалификатор <code>varying</code>, используемый для передачи переменных т вершинного шейдера ко фрагментному.</p>
<p>Я не буду сильно углубляться в подробности, ибо мы в основном рассматриваем *<em>фрагментные шейдеры</em>, но далее в книге вам возможно встретится что-то вроде</p>
<pre><code class="language-glsl">uniform vec2 u_resolution;</code></pre>
<p>Что здесь происходит? Мы задали квалификатор <code>uniform</code> перед типом переменной, указав, что разрешение изображения передаётся в шейдер из CPU. Ширина изображения находится в <code>x</code>-компоненте 2D-вектора, а высота - в <code>y</code>-компоненте.</p>
<p>Когда компилятор видит переменную, объявленную с этим квалификатором, он сделает чтобы вы не могли <em>записать</em> это значение в рантайме.</p>
<p>То же самое применимо к переменной <code>count</code>, которая была пороговым значением в цикле <code>for</code>:</p>
<pre><code class="language-glsl">const float count = 10.;
for( ... )</code></pre>
<p>Когда мы используем квалификатор <code>const</code>, компилятор не даёт нам перезаписать значение, которое в противном случае не было бы константой.</p>
<p>Ещё три квалификатора используются в сигнатурах функций: <code>in</code>, <code>out</code> и <code>inout</code>. В JavaScript переданные в функцию аргументы предназначены только для чтения. Их изменение внутри функции не приводит к изменению значений за её пределами.</p>
<pre><code class="language-glsl">function banana( a ){
    a += 1;
}
var value = 0;
banana( value );
console.log( value );// &gt; 0 ; значение за пределами функции не изменилось</code></pre>
<p>Используя квалификаторы аргументов, можно изменять их поведение:</p>
<ul>
<li><code>in</code> предназначен только для чтения (по умолчанию)</li>
<li><code>out</code>  только для записи: значение такого аргумента нельзя прочитать, но можно записать</li>
<li><code>inout</code>  чтение и запись</li>
</ul>
<p>Перепишем упомянутый выше метод на GLSL:</p>
<pre><code class="language-glsl">void banana( inout float a ){
    a += 1.;
}
float A = 0.;
banana( A ); // теперь A = 1.;</code></pre>
<p>Это поведение сильно отличается от JS и даёт множество возможностей. При этом, не обязательно всегда указывать квалификаторы аргументов. По умолчанию аргументы предназначены только для чтения.</p>
<h4>пространство и координаты</h4>
<p>Напоследок заметим, что в DOM и Canvas 2D ось Y направлена вниз. Это имеет смысл в контексте DOM, ибо соответствует тому, как свёрстана web-страница: навигационная панель наверху, а контент прокручивается вниз. В webgl-элементе ось Y перевёрнута и указывает вверх.</p>
<p>Это означает, что начало координат (точка (0,0)) расположено в левом нижнем, а не в левом верхнем углу контекста. Текстурные координаты так же следуют этому правилу, которое на первый взгляд кажется контринтуитивным.</p>
<h2>На этом всё!</h2>
<p>Конечно, мы могли мы углубиться во всяческие детали, но, как было сказано вначале, эта статья писалась как простое введение для новичков. Здесь уже написано достаточно, чтобы переваривать это некоторое время, но с терпением и практикой этот язык будет становиться всё более естественным для вас.</p>
<p>Надеюсь, этот текст был полезен, а потому самое время приступить к основному содержимому книги!</p>
	</div>
	<hr>
	<ul class="navigationBar">
		<li class="navigationBar" onclick="previusPage()">&lt; &lt; Previous</li>
		<li class="navigationBar" onclick="homePage()"> Home </li>
		<li class="navigationBar" onclick="nextPage()">Next &gt; &gt;</li>
	</ul>

        <footer>
            <p> Copyright 2015 <a href="http://www.patriciogonzalezvivo.com" target="_blank">Patricio Gonzalez Vivo</a> </p>
        </footer>

        <script type="text/javascript" src="..\..\src\main.js" defer=""></script>
        <script>
            (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,"script","//www.google-analytics.com/analytics.js","ga");

            ga("create", "UA-18824436-2", "auto");
            ga("send", "pageview");
        </script>
    </body>
</html>
